# SEO Ads Expert v1.7 Implementation Plan: Alerts, SERP Drift & Strategic Orchestration

## Executive Summary
v1.7 introduces intelligent anomaly detection, SERP drift monitoring, and automated remediation playbooks to the SEO Ads Expert tool. This build-ready implementation fits seamlessly into the existing v1.6 architecture, reusing established components and data structures while adding a lightweight alert engine and strategic orchestration layer.

**Effort**: 2-4 days  
**Risk**: Low (builds on existing infrastructure)  
**Value**: Early detection of problems/opportunities with ready-to-run remedies

## 1. Technical Architecture

### 1.1 Core Components (New)

```
src/
├── alerts/
│   ├── detector-engine.ts        # Unified anomaly detection engine
│   ├── alert-manager.ts          # Alert state management & deduplication
│   ├── detectors/
│   │   ├── spend-detector.ts     # Spend spike/drop detection
│   │   ├── ctr-detector.ts       # CTR anomaly detection
│   │   ├── cpc-detector.ts       # CPC jump detection
│   │   ├── conversion-detector.ts # Conversion rate anomalies
│   │   ├── qs-detector.ts        # Quality Score triage
│   │   ├── serp-drift-detector.ts # SERP feature changes
│   │   └── lp-health-detector.ts # Landing page regressions
│   └── types.ts                  # Alert interfaces & enums
├── playbooks/
│   ├── playbook-engine.ts        # Remediation orchestrator
│   ├── strategies/
│   │   ├── pb-lp-regression.ts   # Landing page fixes
│   │   ├── pb-ctr-drop.ts        # CTR improvement tactics
│   │   ├── pb-cpc-jump.ts        # Cost efficiency fixes
│   │   ├── pb-serp-drift.ts      # SERP adaptation strategies
│   │   └── pb-qs-triage.ts       # Quality Score improvements
│   └── guardrails.ts             # Safety checks & budget caps
└── cli-alerts.ts                  # Alert-specific CLI commands
```

### 1.2 Database Schema (Additions)

```sql
-- MISSING TABLES (Required for v1.7 - Not yet in v1.6)
-- SERP feature tracking
CREATE TABLE fact_serp_snapshot (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  product TEXT NOT NULL,
  market TEXT NOT NULL,
  keyword_cluster TEXT NOT NULL,
  snapshot_date TEXT NOT NULL,
  features_json TEXT NOT NULL,  -- {ai_overview, shopping, video, top_domains}
  top_3_domains TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(product, market, keyword_cluster, snapshot_date)
);

-- Landing page health monitoring
CREATE TABLE fact_url_health (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  url TEXT NOT NULL,
  check_date TEXT NOT NULL,
  status_code INTEGER,
  is_noindex BOOLEAN DEFAULT 0,
  is_soft_404 BOOLEAN DEFAULT 0,
  redirect_chain INTEGER DEFAULT 0,
  canonical_ok BOOLEAN DEFAULT 1,
  response_time_ms INTEGER,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(url, check_date)
);

-- Alert state tracking
CREATE TABLE alerts_state (
  alert_id TEXT PRIMARY KEY,         -- hash(type+entity+window)
  status TEXT NOT NULL,              -- open|ack|snoozed|closed
  severity TEXT NOT NULL,            -- critical|high|medium|low
  first_seen TEXT NOT NULL,
  last_seen TEXT NOT NULL,
  consecutive_occurrences INTEGER DEFAULT 1,  -- For 2-check noise control
  snooze_until TEXT,
  notes TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Alert history for audit trail
CREATE TABLE alerts_history (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  seen_at TEXT NOT NULL,
  alert_id TEXT NOT NULL,
  payload_json TEXT NOT NULL,
  status_change TEXT,
  FOREIGN KEY (alert_id) REFERENCES alerts_state(alert_id)
);

-- Remediation tracking
CREATE TABLE remediation_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  alert_id TEXT NOT NULL,
  playbook_id TEXT NOT NULL,
  actions_json TEXT NOT NULL,
  dry_run BOOLEAN DEFAULT 1,
  applied_at TEXT,
  result_json TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

### 1.3 Integration Points (Reusing Existing)

**Data Sources (Already Available)**:
- `fact_search_terms` - Performance metrics from Google Ads
- `fact_qs` - Quality Score components  
- `fact_serp_snapshot` - SERP features tracking
- `fact_url_health` - Landing page health status
- Google Ads API connector (`src/connectors/google-ads-api.ts`)
- Search Console connector (`src/connectors/search-console.ts`)
- Database Manager (`src/database/database-manager.ts`)

**Output Writers (Reuse)**:
- `src/writers/ads-editor-csv.ts` - For RSA variant exports
- `src/writers/ads-script.ts` - For automated fixes
- `src/writers/negatives-csv-writer.ts` - For negative keyword suggestions

## 2. Alert Types & Detection Logic

### 2.1 Alert Configuration

```typescript
interface AlertConfig {
  type: AlertType;
  thresholds: {
    baseline_days: number;  // Default: 14
    current_days: number;   // Default: 3
    min_volume: number;     // Minimum data points
    change_factor: number;  // Percentage change trigger
    severity_bands: {
      critical: number;
      high: number;
      medium: number;
    };
  };
  cooldown_hours: number;  // Prevent spam (default: 24)
  hysteresis: number;      // Recovery threshold (0.9)
  noise_control: {
    strategy: 'consecutive' | 'cooldown' | 'both';
    consecutive_checks: number;  // Default: 2
  };
}
```

### 2.1a Specific Alert Thresholds (From Ideas Doc)

```json
// alert-thresholds.json
{
  "spend_spike": {
    "factor_increase": 1.5,      // current >= baseline * 1.5
    "min_absolute_increase": 10,  // OR current >= baseline + $10
    "min_clicks": 50,             // Minimum clicks to trigger
    "severity_bands": {
      "critical": 2.0,  // 2x spend
      "high": 1.5,      // 1.5x spend  
      "medium": 1.3     // 1.3x spend
    }
  },
  "spend_drop": {
    "factor_decrease": 0.5,       // current <= baseline * 0.5
    "min_impressions": 1000       // With sufficient impressions
  },
  "ctr_drop": {
    "factor": 0.7,                // CTR_current / CTR_baseline <= 0.7
    "min_impressions": 1000,
    "severity_bands": {
      "critical": 0.5,  // 50% drop
      "high": 0.7,      // 30% drop
      "medium": 0.8     // 20% drop
    }
  },
  "cpc_jump": {
    "factor": 1.3,                // CPC_current / CPC_baseline >= 1.3
    "min_clicks": 100,
    "severity_bands": {
      "critical": 1.5,  // 50% increase
      "high": 1.3,      // 30% increase
      "medium": 1.2     // 20% increase
    }
  },
  "conversion_drop": {
    "factor": 0.7,                // rate_current / rate_baseline <= 0.7
    "min_sessions": 300
  },
  "quality_score": {
    "threshold": 4,               // QS <= 4 triggers alert
    "component_trigger": "Below average"  // Any component below average
  },
  "serp_drift": {
    "severity_mapping": {
      "ai_overview_and_shopping": "high",     // Both features
      "ai_overview_only": "medium",           // Single feature
      "shopping_only": "medium",              // Single feature
      "video_pack": "medium",                 // Video feature
      "new_top3_domain": "medium"             // Competitor change
    }
  },
  "lp_regression": {
    "always_critical": true,      // Any LP issue is critical
    "block_applies": true          // Blocks all remediation
  }
}
```

### 2.2 Detection Algorithms

```typescript
// Core anomaly detection with noise control
class DetectorEngine {
  async detectAnomalies(
    entity: Entity,
    window: TimeWindow
  ): Promise<Alert[]> {
    const baseline = await this.computeBaseline(entity, window.baseline_days);
    const current = await this.computeCurrent(entity, window.current_days);
    
    // Z-score based anomaly detection
    const zScore = (current.value - baseline.mean) / baseline.stdDev;
    
    // Map to severity
    const severity = this.mapSeverity(zScore, entity.type);
    
    // Noise control: Check consecutive occurrences OR cooldown
    const shouldAlert = await this.applyNoiseControl(entity, severity);
    
    if (shouldAlert) {
      return this.createAlert(entity, baseline, current, severity);
    }
  }
  
  async applyNoiseControl(entity: Entity, severity: Severity): Promise<boolean> {
    const alertId = this.generateAlertId(entity);
    const state = await this.getAlertState(alertId);
    
    // Strategy: 'both' = require consecutive checks AND respect cooldown
    // Strategy: 'consecutive' = require N consecutive checks
    // Strategy: 'cooldown' = respect cooldown period only
    
    if (this.config.noise_control.strategy === 'consecutive' || 
        this.config.noise_control.strategy === 'both') {
      if (state.consecutive_occurrences < this.config.noise_control.consecutive_checks) {
        await this.incrementConsecutive(alertId);
        return false; // Don't alert yet
      }
    }
    
    if (this.config.noise_control.strategy === 'cooldown' || 
        this.config.noise_control.strategy === 'both') {
      if (state.last_seen && this.isWithinCooldown(state.last_seen)) {
        return false; // Still in cooldown
      }
    }
    
    return true; // Alert should fire
  }
}
```

## 3. Playbook Implementation

### 3.1 Playbook Structure

```typescript
interface Playbook {
  id: string;
  alertType: AlertType;
  steps: PlaybookStep[];
  guardrails: Guardrail[];
  dryRunDefault: boolean;
}

interface PlaybookStep {
  action: string;
  params: Record<string, any>;
  validator?: () => Promise<boolean>;
  output: OutputType;  // csv|json|ads-script
}
```

### 3.2 Example Playbook: CTR Drop

```typescript
class CTRDropPlaybook implements Playbook {
  async execute(alert: Alert, options: PlaybookOptions): Promise<Remediation> {
    const steps: RemediationStep[] = [];
    
    // Step 1: Analyze QS components
    const qsAnalysis = await this.analyzeQualityScore(alert.entity);
    
    // Step 2: Generate RSA variants if Ad Relevance is low
    if (qsAnalysis.adRelevance === 'Below average') {
      const variants = await this.generateRSAVariants({
        strategy: 'keyword_insertion',
        count: 3,
        testing_budget: 50
      });
      steps.push({
        action: 'create_rsa_variants',
        artifacts: variants,
        output: 'ads-editor.csv'
      });
    }
    
    // Step 3: Add assets if missing
    const assetGaps = await this.identifyAssetGaps(alert.entity);
    if (assetGaps.length > 0) {
      steps.push({
        action: 'add_assets',
        artifacts: await this.generateAssets(assetGaps),
        output: 'assets.csv'
      });
    }
    
    // Step 4: Optional bid adjustment
    if (options.allowBidChanges && qsAnalysis.cpcTrend === 'rising') {
      steps.push({
        action: 'adjust_bid',
        params: { change: -0.1, cap: alert.entity.maxCpc * 0.9 }
      });
    }
    
    return this.applyGuardrails(steps, options.dryRun);
  }
}
```

## 4. CLI Commands

### 4.1 New Commands

```bash
# Check for alerts across all products
seo-ads check --product all --window 14d:3d

# Check specific product with custom thresholds
seo-ads check --product palettekit --sensitivity high

# Apply remediation (dry-run by default)
seo-ads remedy --alert-id ctr_drop:adgroup:palettekit:web_color --dry-run

# Apply remediation for real (with guardrails)
seo-ads remedy --alert-id <id> --apply

# Alert management
seo-ads alerts --list --status open
seo-ads alerts --ack <id>
seo-ads alerts --snooze <id> --until 2025-09-15
seo-ads alerts --close <id> --notes "Fixed by increasing bids"

# Simulate alerts for testing
seo-ads alerts --simulate ctr_drop --entity "AdGroup:PaletteKit AU" --factor 0.6
```

### 4.2 Integration with Existing Commands

```typescript
// Extend existing generate command
program
  .command('generate')
  .option('--check-alerts', 'Include alert check in generation')
  .action(async (options) => {
    // Existing generation logic...
    
    if (options.checkAlerts) {
      const alertEngine = new AlertEngine();
      const alerts = await alertEngine.check(product);
      
      if (alerts.critical.length > 0) {
        console.warn('⚠️ Critical alerts detected! Run "seo-ads alerts --list" for details');
      }
    }
  });
```

## 5. Implementation Tasks

### Phase 1: Alert Detection (Day 1)
1. ✅ Create alert database schema
2. ✅ Implement DetectorEngine base class
3. ✅ Build individual detectors (7 types)
4. ✅ Create AlertManager for state management
5. ✅ Add alerts.json output writer
6. ✅ Implement CLI check command

### Phase 2: Playbooks (Day 2)
1. ✅ Create PlaybookEngine orchestrator
2. ✅ Implement 5 core playbooks
3. ✅ Add guardrails system
4. ✅ Build remediation artifact generators
5. ✅ Implement CLI remedy command

### Phase 3: Integration & Testing (Day 3)
1. ✅ Connect to existing data sources
2. ✅ Add alert state management (ack/snooze)
3. ✅ Create simulation mode for testing
4. ✅ Unit tests for detectors
5. ✅ Integration tests for playbooks
6. ✅ End-to-end workflow tests

### Phase 4: Polish & Documentation (Day 4)
1. ✅ Console output formatting
2. ✅ Alert severity tuning
3. ✅ Documentation update
4. ✅ Performance optimization
5. ✅ Production deployment checklist

## 6. Testing Strategy

### 6.1 Unit Tests

```typescript
describe('AlertDetectors', () => {
  test('CTR drop detection', async () => {
    const detector = new CTRDetector();
    const mockData = {
      baseline: { ctr: 0.034, impressions: 10000 },
      current: { ctr: 0.021, impressions: 2000 }
    };
    
    const alert = await detector.detect(mockData);
    expect(alert.severity).toBe('high');
    expect(alert.metrics.change).toBeCloseTo(-0.38);
  });
});
```

### 6.2 Integration Tests

```typescript
describe('Playbook Integration', () => {
  test('CTR drop remediation generates valid exports', async () => {
    const alert = createMockAlert('ctr_drop');
    const playbook = new CTRDropPlaybook();
    
    const result = await playbook.execute(alert, { dryRun: true });
    
    expect(result.artifacts).toContainKey('ads-editor.csv');
    expect(result.guardrailsPassed).toBe(true);
  });
});
```

### 6.3 End-to-End Tests

```bash
# Test alert detection
npm test -- --testNamePattern="Alert detection workflow"

# Test remediation with dry-run
npm test -- --testNamePattern="Remediation dry-run"

# Test guardrails
npm test -- --testNamePattern="Guardrails block unsafe changes"
```

## 7. Output Artifacts

### 7.1 alerts.json Structure

```json
{
  "generated_at": "2025-09-08T03:00:00Z",
  "product": "palettekit",
  "summary": {
    "total": 5,
    "critical": 1,
    "high": 2,
    "medium": 2,
    "new": 3,
    "persistent": 2
  },
  "alerts": [
    {
      "id": "lp_regression:palettekit:convertmyfile:heic-to-jpg",
      "type": "lp_regression",
      "severity": "critical",
      "entity": {
        "product": "palettekit",
        "url": "/convertmyfile/heic-to-jpg",
        "campaign": "ConvertMyFile_Search_US",
        "ad_group": "HEIC Converter"
      },
      "metrics": {
        "previous_status": 200,
        "current_status": "noindex",
        "affected_clicks": 450,
        "affected_cost": 325.50
      },
      "detection": {
        "first_seen": "2025-09-07T12:00:00Z",
        "last_seen": "2025-09-08T03:00:00Z",
        "occurrences": 3
      },
      "playbook": "pb_lp_regression",
      "remediation": {
        "actions": [
          {"type": "block_applies", "target": "url:/convertmyfile/heic-to-jpg"},
          {"type": "fix_suggestion", "details": "Remove noindex meta tag"}
        ],
        "priority": "immediate",
        "estimated_recovery": "24-48 hours"
      }
    }
  ]
}
```

### 7.2 Console Output Format

```
╔════════════════════════════════════════════════════════════════╗
║ ALERTS SUMMARY - PaletteKit (AU/US/GB)                        ║
╟────────────────────────────────────────────────────────────────╢
║ 5 alerts (1 critical, 2 high, 2 medium) | 3 new, 2 ongoing   ║
╚════════════════════════════════════════════════════════════════╝

🚨 CRITICAL  LP_REGRESSION    /convertmyfile/heic-to-jpg
   Status: 200→noindex | Impact: 450 clicks, $325.50 | Action: BLOCKED

⚠️  HIGH      CTR_DROP        AdGroup "Web Color Picker" AU
   Change: -38% vs 14d avg | Volume: 12.4k impr | Playbook: pb_ctr_drop

⚠️  HIGH      SERP_DRIFT      Cluster "webp to png" US
   Change: AI Overview appeared | Competition: +2 new domains | Action: Review

📊 MEDIUM    CPC_JUMP        Campaign NoteBridge_US
   Change: +42% CPC | Volume: 380 clicks | Suggestion: Add negatives

📊 MEDIUM    QS_TRIAGE       AdGroup "Chrome Note Taking"
   QS: 4/10 | LP Experience: Below avg | Action: Content improvements

Run 'seo-ads remedy --alert-id <id> --dry-run' to see remediation plans
```

## 8. Guardrails & Safety

### 8.1 Budget Guardrails

```typescript
class BudgetGuardrail implements Guardrail {
  async check(action: RemediationAction): Promise<GuardrailResult> {
    // Never exceed campaign daily budget
    if (action.estimatedCost > campaign.dailyBudget * 0.1) {
      return { passed: false, reason: 'Exceeds 10% of daily budget' };
    }
    
    // Enforce gradual changes
    if (action.type === 'bid_change' && Math.abs(action.change) > 0.2) {
      return { passed: false, reason: 'Bid change exceeds 20% limit' };
    }
    
    return { passed: true };
  }
}
```

### 8.2 Landing Page Health Gate

```typescript
class LandingPageGuardrail implements Guardrail {
  async check(action: RemediationAction): Promise<GuardrailResult> {
    const health = await this.urlHealthChecker.check(action.targetUrl);
    
    if (health.status !== 200 || health.noindex || health.soft404) {
      return { 
        passed: false, 
        reason: 'Landing page fails health check',
        blocker: true  // This is a hard block
      };
    }
    
    return { passed: true };
  }
}
```

## 9. Performance Considerations

### 9.1 Detection Performance

```typescript
// Batch detection for efficiency
class BatchDetector {
  async detectAll(products: string[]): Promise<AlertBatch> {
    // Parallel detection with concurrency limit
    const results = await pLimit(5)(
      products.map(product => () => this.detectProduct(product))
    );
    
    // Deduplicate cross-product alerts
    return this.deduplicateAlerts(results);
  }
}
```

### 9.2 Caching Strategy

```typescript
// Cache baseline calculations
class BaselineCache {
  private cache = new Map<string, BaselineData>();
  private ttl = 3600000; // 1 hour
  
  async getBaseline(entity: Entity, days: number): Promise<BaselineData> {
    const key = `${entity.id}:${days}`;
    
    if (this.cache.has(key) && !this.isExpired(key)) {
      return this.cache.get(key)!;
    }
    
    const baseline = await this.computeBaseline(entity, days);
    this.cache.set(key, baseline);
    return baseline;
  }
}
```

## 10. Migration & Rollback Plan

### 10.1 Database Migration

```typescript
// Safe migration with rollback support
class V17Migration {
  async up(): Promise<void> {
    await this.db.exec(`
      BEGIN TRANSACTION;
      
      -- Create new tables
      CREATE TABLE IF NOT EXISTS alerts_state (...);
      CREATE TABLE IF NOT EXISTS alerts_history (...);
      CREATE TABLE IF NOT EXISTS remediation_log (...);
      
      -- Add version marker
      INSERT INTO schema_version (version, applied_at) 
      VALUES ('1.7.0', datetime('now'));
      
      COMMIT;
    `);
  }
  
  async down(): Promise<void> {
    await this.db.exec(`
      DROP TABLE IF EXISTS remediation_log;
      DROP TABLE IF EXISTS alerts_history;
      DROP TABLE IF EXISTS alerts_state;
    `);
  }
}
```

### 10.2 Feature Flags

```typescript
// Gradual rollout with feature flags
const features = {
  alerts: {
    enabled: process.env.ENABLE_ALERTS !== 'false',
    detectors: {
      spend: true,
      ctr: true,
      cpc: true,
      conversion: process.env.ENABLE_CONVERSION_ALERTS === 'true',
      qs: true,
      serp_drift: true,
      lp_health: true
    }
  },
  playbooks: {
    enabled: process.env.ENABLE_PLAYBOOKS !== 'false',
    autoApply: false,  // Always false in v1.7
    dryRunDefault: true
  }
};
```

## 11. Success Criteria

### Acceptance Tests
- [ ] `seo-ads check` produces alerts.json with correct structure
- [ ] LP regression blocks any apply operations
- [ ] CTR drop alert generates valid RSA variant exports
- [ ] SERP drift detection identifies feature changes
- [ ] Snooze/Ack prevents duplicate alerts
- [ ] Guardrails prevent unsafe changes
- [ ] Performance: Detection completes in <60s with warm cache
- [ ] All existing v1.6 functionality remains unchanged

### Production Readiness
- [ ] Database migrations tested and reversible
- [ ] Feature flags configured for gradual rollout
- [ ] Monitoring metrics exposed via health endpoint
- [ ] Documentation updated with v1.7 features
- [ ] Alert thresholds tuned based on historical data

## 12. Risk Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| Noisy alerts | High | Min volume gates, hysteresis, cooldown periods |
| False positives | Medium | Conservative thresholds, severity banding |
| Performance impact | Low | Caching, batch processing, async detection |
| Breaking changes | Low | Feature flags, comprehensive tests |

## 13. Documentation Updates

### Files to Update
- `README.md` - Add v1.7 alert commands
- `CLAUDE.md` - Update with v1.7 features
- `docs/alerts-guide.md` - New user guide for alerts
- `docs/playbooks-reference.md` - Playbook documentation

### Example Documentation

```markdown
## Alert System (v1.7)

The SEO Ads Expert now includes intelligent anomaly detection:

### Quick Start
```bash
# Check for alerts
seo-ads check --product palettekit

# View alerts
seo-ads alerts --list

# Apply remediation
seo-ads remedy --alert-id <id> --dry-run
```

### Alert Types
- **LP Regression** (Critical): Landing page health issues
- **CTR Drop** (High): Click-through rate anomalies
- **SERP Drift** (High): Search results page changes
- **CPC Jump** (Medium): Cost efficiency issues
- **QS Triage** (Medium): Quality Score problems
```

## Timeline

**Day 1**: Alert detection engine + database schema  
**Day 2**: Playbook implementation + guardrails  
**Day 3**: Integration + testing  
**Day 4**: Polish + documentation  

Total: **2-4 days** (depending on testing depth)

## Conclusion

v1.7 seamlessly extends the SEO Ads Expert with intelligent monitoring and automated remediation while maintaining full compatibility with existing v1.6 functionality. The implementation reuses established patterns, minimizes new dependencies, and provides immediate value through early problem detection and ready-to-run fixes.

The modular architecture ensures easy maintenance, gradual rollout via feature flags, and safe operation through comprehensive guardrails. With <60s detection runtime and dry-run defaults, v1.7 delivers enterprise-grade monitoring without operational risk.