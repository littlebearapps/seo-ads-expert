# v1.3 Implementation Plan: Official APIs & One-Click Apply

## Executive Summary

v1.3 transforms the SEO & Ads Expert Tool from a planning and analysis system to an **active campaign management platform** with direct API integration, automated application of changes, and cross-platform support for Microsoft Ads. This version introduces safe, guardrail-protected write operations while maintaining the analytical excellence of v1.2.

**Timeline**: 5-7 days  
**Core Theme**: From "plan & export" to "plan & apply (with guardrails)"  
**Risk Level**: Medium (API writes require careful guardrails)  
**Dependencies**: Google Ads API approval (in progress)  
**Integration Confidence**: 95% - Seamless fit with v1.2 architecture confirmed

## Architecture Overview

```
v1.3 System Architecture (Building on v1.2 Foundation):
┌─────────────────────────────────────────────────────────────┐
│          Strategic Orchestrator (v1.2 Core - Extended)       │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ • Existing: 9 Analyzers, Generators, Monitors          │ │
│  │ • Existing: Performance Monitor with Circuit Breakers  │ │
│  │ • Existing: Cache System (1-week TTL, quota tracking)  │ │
│  │ • NEW: Campaign Reconciler Integration                 │ │
│  └────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│              NEW: Campaign Management Layer                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  Google Ads  │  │  Microsoft   │  │   Mutation    │    │
│  │  API Client  │  │  Ads Export  │  │   Guard       │    │
│  │ (connectors/)│  │ (writers/)   │  │  (monitors/)  │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
├─────────────────────────────────────────────────────────────┤
│         Enhanced Safety & Audit (Extends v1.2 Monitors)     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  Audit Log   │  │  Dry Run     │  │ Campaign      │    │
│  │   System     │  │  Simulator   │  │ Reconciler    │    │
│  │ (monitors/)  │  │ (monitors/)  │  │ (analyzers/)  │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
├─────────────────────────────────────────────────────────────┤
│                   MCP Server Layer (New)                     │
│         Exposing all v1.2 + v1.3 capabilities               │
│                      (src/mcp/)                             │
└─────────────────────────────────────────────────────────────┘
```

### File Structure Integration

```
src/
├── analyzers/               # Existing directory (9 analyzers)
│   ├── strategic-orchestrator.ts  # EXTEND with mutation context
│   └── campaign-reconciler.ts     # NEW: Live vs planned comparison
├── connectors/              # Existing directory (3 connectors)
│   ├── google-ads-api.ts         # NEW: Follow kwp-csv.ts pattern
│   └── bing-keywords.ts          # NEW: Bing keyword research
├── monitors/                # Existing directory (3 monitors)
│   ├── performance.ts            # EXTEND with mutation budgets
│   ├── mutation-guard.ts         # NEW: Extends performance.ts
│   └── audit-logger.ts          # NEW: Audit trail system
├── writers/                 # Existing directory (3 writers)
│   ├── microsoft-ads-csv.ts      # NEW: Bulk import format
│   └── mutation-applier.ts      # NEW: Safe write operations
└── mcp/                     # NEW directory
    ├── seo-ads-server.ts         # MCP server implementation
    └── tool-handlers.ts          # MCP tool definitions
```

## Task Breakdown

### Task 1: Google Ads API Integration (1.5 days)
**Priority**: CRITICAL  
**Dependencies**: API credentials, OAuth setup

#### Subtasks:
1. **API Client Setup** (4h)
   - Implement OAuth 2.0 flow with refresh token management
   - Create GoogleAdsApiClient class with connection pooling
   - Set up developer token and customer ID configuration
   - Implement retry logic with exponential backoff

2. **GAQL Query Builder** (6h)
   - Build type-safe GAQL query generator
   - Implement campaign/ad group/keyword/ad readers
   - Create response parsing with Zod schemas
   - Add pagination support for large accounts

3. **Reconciliation Engine** (4h)
   - Compare API data with ads.json plans
   - Identify discrepancies and drift
   - Generate reconciliation reports
   - Flag manual changes made outside the tool

#### Success Criteria:
- ✅ Successfully authenticate and read account data
- ✅ GAQL queries return accurate campaign structures
- ✅ Reconciliation identifies 100% of discrepancies
- ✅ API calls respect rate limits (8,000/day)

#### Implementation:
```typescript
// src/connectors/google-ads-api.ts (follows existing connector patterns)
export class GoogleAdsApiClient {
  private cache: CacheManager; // Reuse v1.2 cache system
  private performanceMonitor: PerformanceMonitor; // Reuse v1.2 monitoring
  
  async authenticate(): Promise<void>
  async getCampaigns(customerId: string): Promise<Campaign[]>
  async getAdGroups(campaignId: string): Promise<AdGroup[]>
  async reconcile(planned: AdsJson, actual: ApiData): Promise<ReconciliationReport>
}

// src/analyzers/campaign-reconciler.ts (extends existing analyzer pattern)
export class CampaignReconciler {
  constructor(
    private googleAdsClient: GoogleAdsApiClient,
    private opportunityAnalyzer: OpportunityAnalyzer // Reuse v1.2
  ) {}
  
  async analyzeDrift(planned: AdsJson, live: CampaignData): Promise<DriftReport>
}
```

#### Reusable v1.2 Components:
- **CacheManager**: 1-week TTL perfect for API response caching
- **PerformanceMonitor**: Circuit breaker protection for API calls
- **Zod Schemas**: Extend existing validation patterns
- **Error Handling**: Apply established patterns from connectors/

---

### Task 2: Safe Write Operations & Guardrails (1.5 days)
**Priority**: CRITICAL  
**Dependencies**: Task 1 completion

#### Subtasks:
1. **Mutation Builder** (4h)
   - Create type-safe mutation operations
   - Implement create/update/pause logic
   - Build batch operation support
   - Add rollback capability

2. **Guardrail System** (6h)
   - Daily budget cap enforcement (default A$10)
   - Device targeting restrictions (desktop-only default)
   - Landing page health checks (404 detection)
   - Negative keyword list validation
   - Maximum bid limits

3. **Dry Run Mode** (4h)
   - Generate detailed diff before execution
   - Preview all changes in human-readable format
   - Calculate estimated impact
   - Require explicit confirmation

#### Success Criteria:
- ✅ No writes occur without passing all guardrails
- ✅ Budget caps prevent overspend scenarios
- ✅ 404 landing pages block campaign activation
- ✅ Dry run accurately predicts changes

#### Implementation:
```typescript
// src/monitors/mutation-guard.ts (extends existing performance.ts patterns)
export class MutationGuard extends PerformanceMonitor {
  private budgetEnforcer: BudgetEnforcer; // Reuse v1.2 budget tracking
  
  async validateMutation(mutation: Mutation): Promise<GuardrailResult> {
    // Apply same circuit breaker patterns as v1.2
    return this.executeWithCircuitBreaker(async () => {
      const budgetCheck = await this.budgetEnforcer.validate(mutation);
      const landingPageCheck = await this.checkLandingPages(mutation.urls);
      return this.consolidateResults([budgetCheck, landingPageCheck]);
    });
  }
}

// src/writers/mutation-applier.ts (follows existing writer patterns)
export class MutationApplier {
  constructor(
    private googleAdsClient: GoogleAdsApiClient,
    private auditLogger: AuditLogger,
    private performanceMonitor: PerformanceMonitor // Reuse v1.2
  ) {}
  
  async applyChanges(
    changes: PlannedChanges,
    options: { dryRun: boolean; confirm: boolean }
  ): Promise<MutationResult>
}
```

#### Reusable v1.2 Components:
- **PerformanceMonitor**: Circuit breaker patterns for mutation safety
- **BudgetEnforcer**: Existing budget tracking and limits
- **Writers Pattern**: Apply same patterns from CSV/JSON/Markdown writers
- **Error Handling**: Use established retry and fallback patterns

---

### Task 3: Negative Keywords Management (0.5 days)
**Priority**: HIGH  
**Dependencies**: Task 2

#### Subtasks:
1. **Shared List Management** (2h)
   - Create product-specific negative lists
   - Implement list versioning
   - Auto-attach to campaigns

2. **Negative Sync Engine** (2h)
   - Sync negatives from waste analysis
   - Merge with existing lists
   - Conflict resolution logic

#### Success Criteria:
- ✅ One shared negative list per product
- ✅ Auto-attachment to all relevant campaigns
- ✅ No duplicate negatives
- ✅ Audit trail for all changes

#### Implementation:
```typescript
// src/analyzers/negative-keywords-manager.ts (extends WasteAnalyzer from v1.2)
export class NegativeKeywordsManager extends WasteAnalyzer {
  constructor(
    private googleAdsClient: GoogleAdsApiClient,
    private wasteAnalyzer: WasteAnalyzer // Reuse v1.2 waste detection
  ) {}
  
  async syncNegativeKeywords(product: string): Promise<NegativeListUpdate> {
    const wasteTerms = await this.wasteAnalyzer.identifyWastedSpend();
    const existingList = await this.googleAdsClient.getNegativeList(product);
    return this.mergeAndVersion(wasteTerms, existingList);
  }
}
```

#### Reusable v1.2 Components:
- **WasteAnalyzer**: Already identifies low-performing keywords
- **Product Categorization**: Use existing product taxonomy
- **Audit System**: Apply v1.2 logging patterns

---

### Task 4: Microsoft Ads Integration (1 day)
**Priority**: HIGH  
**Dependencies**: None

#### Subtasks:
1. **Export Translator** (4h)
   - Map Google Ads structure to Microsoft format
   - Generate bulk import CSV
   - Handle platform-specific differences

2. **Bing Keyword Research** (4h)
   - Integrate Bing Keyword API
   - Merge with existing keyword data
   - Calculate Edge/Bing market opportunity

#### Success Criteria:
- ✅ Valid Microsoft Ads bulk import CSV
- ✅ No schema errors on import
- ✅ Keyword data includes Bing metrics
- ✅ Platform parity for core features

#### Implementation:
```typescript
// src/writers/microsoft-ads-csv.ts (follows existing CSV writer patterns)
export class MicrosoftAdsCSVWriter extends CSVWriter {
  constructor(
    private strategicOrchestrator: StrategicOrchestrator // Reuse v1.2
  ) {}
  
  async exportBulkCsv(campaigns: Campaign[]): Promise<string> {
    // Apply same CSV generation patterns as v1.2
    const mappedData = this.mapGoogleToMicrosoft(campaigns);
    return this.generateCSV(mappedData);
  }
}

// src/connectors/bing-keywords.ts (follows connector patterns)
export class BingKeywordsConnector {
  constructor(
    private cache: CacheManager, // Reuse v1.2 cache
    private performanceMonitor: PerformanceMonitor // Reuse v1.2
  ) {}
  
  async getKeywordData(terms: string[]): Promise<BingKeywordData[]>
}
```

#### Reusable v1.2 Components:
- **CSVWriter**: Base patterns for CSV generation
- **Connector Architecture**: Apply same patterns as kwp-csv.ts
- **Cache System**: 1-week TTL for Bing API responses

---

### Task 5: MCP Server Implementation (1 day)
**Priority**: MEDIUM  
**Dependencies**: Tasks 1-4

#### Subtasks:
1. **Tool Definitions** (4h)
   - Define MCP tool schemas
   - Implement tool handlers
   - Add streaming support

2. **Claude Integration** (4h)
   - Create conversation flows
   - Implement safety confirmations
   - Add progress reporting

#### Success Criteria:
- ✅ All v1.3 features accessible via MCP
- ✅ Claude can execute full workflow
- ✅ Safety confirmations required for writes
- ✅ Real-time progress updates

#### MCP Tools:
```typescript
tools:
  - seo_ads_plan: Generate strategic plan
  - preview_changes: Show diff before applying
  - apply_changes: Execute mutations (with confirmation)
  - export_campaigns: Generate export files
  - audit_history: Review change history
```

---

### Task 6: Audit & Compliance System (0.5 days)
**Priority**: HIGH  
**Dependencies**: Task 2

#### Subtasks:
1. **Audit Logger** (2h)
   - Timestamp all operations
   - Capture full request/response
   - Store in audit/ directory

2. **Compliance Reports** (2h)
   - Generate change summaries
   - Track approvals and confirmations
   - Create rollback points

#### Success Criteria:
- ✅ Every write operation logged
- ✅ Non-repudiable audit trail
- ✅ Rollback capability within 24h
- ✅ Compliance with data regulations

---

### Task 7: Enhanced Validation & Safety (0.5 days)
**Priority**: MEDIUM  
**Dependencies**: Tasks 1-6

#### Subtasks:
1. **URL Health Checks** (2h)
   - Sitemap validation
   - Robots.txt compliance
   - SSL certificate validation

2. **Performance Validation** (2h)
   - Lighthouse metrics integration
   - Core Web Vitals checks
   - Mobile usability validation

#### Success Criteria:
- ✅ No broken links in campaigns
- ✅ All pages pass Core Web Vitals
- ✅ Mobile-friendly validation
- ✅ HTTPS enforcement

---

## Testing Strategy

### Unit Tests
- API client methods (mocked responses)
- Guardrail validations
- Mutation builders
- Export formatters

### Integration Tests
- End-to-end API flow (test account)
- Dry run vs actual changes comparison
- Microsoft Ads CSV validation
- MCP server communication

### Safety Tests
- Budget cap enforcement
- 404 detection and blocking
- Rollback procedures
- Audit log integrity

## Risk Mitigation

| Risk | Mitigation Strategy |
|------|-------------------|
| Accidental overspend | Hard budget caps, dry run mode, confirmation required |
| API rate limits | Request queuing, exponential backoff, caching |
| Bad landing pages | Pre-flight health checks, continuous monitoring |
| Data loss | Audit logs, versioning, rollback capability |
| Platform differences | Abstraction layer, platform-specific validators |

## Success Metrics

### Technical Metrics
- API integration reliability: >99.9%
- Guardrail effectiveness: 100% blocking rate
- Audit completeness: 100% of operations logged
- MCP response time: <2s for all operations

### Business Metrics
- Time to apply changes: <30 seconds (from plan to live)
- Error rate in campaigns: <0.1%
- Platform coverage: Google Ads + Microsoft Ads
- Automation level: 95% of operations automated

## Implementation Schedule

**Day 1-2**: Google Ads API Integration + GAQL Implementation  
**Day 3**: Safe Write Operations & Guardrails  
**Day 4**: Microsoft Ads Integration + Negative Keywords  
**Day 5**: MCP Server Implementation  
**Day 6**: Audit System + Enhanced Validation  
**Day 7**: Testing, Documentation, and Polish

## Dependencies & Prerequisites

1. **Google Ads API Access**
   - Developer token approved
   - OAuth 2.0 credentials configured
   - Test account available

2. **Microsoft Ads Account**
   - API credentials
   - Bulk import access

3. **Infrastructure**
   - Secure credential storage (.env)
   - Audit log directory structure
   - MCP server environment

## Backwards Compatibility

All v1.2 features remain fully functional:
- Strategic intelligence generation
- Opportunity analysis
- Content planning
- Report generation

v1.3 adds new capabilities without breaking existing workflows.

## Future Considerations (v1.4+)

- Facebook/Meta Ads integration
- Amazon Ads support
- Real-time bid management
- Automated budget optimization
- Machine learning for bid strategies
- Cross-channel attribution

## Schema Extensions for v1.3

### Extending UnifiedOpportunitySchema
```typescript
// Extend existing v1.2 schema with API data
export const UnifiedOpportunitySchemaV3 = UnifiedOpportunitySchema.extend({
  // Add API-specific fields
  apiData: z.object({
    source: z.enum(['google_ads_api', 'microsoft_ads_api', 'manual']),
    lastSyncedAt: z.string().datetime(),
    accountId: z.string(),
    customerId: z.string().optional(),
    campaignStatus: z.enum(['enabled', 'paused', 'removed']).optional(),
    performanceStats: z.object({
      impressions: z.number(),
      clicks: z.number(),
      conversions: z.number(),
      cost: z.number(),
      ctr: z.number(),
      conversionRate: z.number()
    }).optional()
  }).optional(),
  
  // Add mutation tracking
  mutations: z.array(z.object({
    type: z.enum(['create', 'update', 'pause', 'remove']),
    timestamp: z.string().datetime(),
    applied: z.boolean(),
    rollbackAvailable: z.boolean(),
    changes: z.record(z.any())
  })).optional(),
  
  // Add reconciliation data
  reconciliation: z.object({
    hasDiscrepancies: z.boolean(),
    discrepancies: z.array(z.object({
      field: z.string(),
      planned: z.any(),
      actual: z.any(),
      severity: z.enum(['low', 'medium', 'high'])
    })),
    lastChecked: z.string().datetime()
  }).optional()
});
```

### Extending PerformanceBudgetSchema
```typescript
// Enhanced budget tracking for API operations
export const PerformanceBudgetSchemaV3 = PerformanceBudgetSchema.extend({
  apiQuotas: z.object({
    googleAds: z.object({
      dailyLimit: z.number().default(8000),
      used: z.number().default(0),
      resetAt: z.string().datetime()
    }),
    microsoftAds: z.object({
      dailyLimit: z.number().default(5000),
      used: z.number().default(0),
      resetAt: z.string().datetime()
    })
  }),
  
  mutationBudget: z.object({
    maxDailySpend: z.number().default(10), // A$10 default
    currentSpend: z.number().default(0),
    pendingChanges: z.number().default(0),
    enforcementLevel: z.enum(['soft', 'hard']).default('hard')
  }),
  
  guardrailOverrides: z.object({
    allowedDomains: z.array(z.string()).optional(),
    blockedKeywords: z.array(z.string()).optional(),
    maxBidOverride: z.number().optional()
  }).optional()
});
```

## Integration Patterns from v1.2

### Error Handling Pattern
```typescript
// Apply v1.2's robust error handling to API operations
export class GoogleAdsApiClient {
  async executeWithRetry<T>(
    operation: () => Promise<T>,
    options: RetryOptions = {}
  ): Promise<T> {
    // Reuse v1.2's retry logic with exponential backoff
    const maxRetries = options.maxRetries ?? 3;
    const baseDelay = options.baseDelay ?? 1000;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        if (!this.isRetryable(error) || i === maxRetries - 1) {
          throw error;
        }
        await this.delay(baseDelay * Math.pow(2, i));
      }
    }
  }
}
```

### Cache Integration Pattern
```typescript
// Extend v1.2's cache system for API responses
export class ApiCacheManager extends CacheManager {
  constructor() {
    super({
      ttl: 7 * 24 * 60 * 60 * 1000, // 1 week (same as v1.2)
      maxSize: 100 * 1024 * 1024, // 100MB
      compressionEnabled: true
    });
  }
  
  getCacheKey(request: ApiRequest): string {
    // Generate stable cache keys for API requests
    return crypto.createHash('sha256')
      .update(JSON.stringify({
        endpoint: request.endpoint,
        params: request.params,
        customerId: request.customerId
      }))
      .digest('hex');
  }
}
```

### Performance Monitoring Pattern
```typescript
// Apply v1.2's circuit breaker to API calls
export class ApiCircuitBreaker extends PerformanceMonitor {
  async executeApiCall<T>(
    apiCall: () => Promise<T>,
    resourceType: string
  ): Promise<T> {
    return this.executeWithCircuitBreaker(
      apiCall,
      {
        threshold: 5,        // 5 failures trigger circuit
        timeout: 60000,      // 1 minute cooldown
        halfOpenRequests: 1  // Test with 1 request
      }
    );
  }
}
```

### Zod Validation Pattern
```typescript
// Consistent validation across v1.3 like v1.2
export const validateApiResponse = <T extends z.ZodType>(
  schema: T,
  data: unknown
): z.infer<T> => {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.error('API response validation failed', {
        errors: error.errors,
        data: JSON.stringify(data).substring(0, 1000)
      });
      throw new ValidationError('Invalid API response', error.errors);
    }
    throw error;
  }
};
```

## Conclusion

v1.3 represents a major leap from analysis to action, transforming the SEO & Ads Expert Tool into a complete campaign management platform. With robust guardrails, comprehensive auditing, and cross-platform support, it enables safe, efficient, and scalable digital marketing operations.

The implementation maintains the high code quality standards established in v1.2 while adding powerful new capabilities that directly impact campaign performance and operational efficiency. By leveraging 95% of v1.2's existing patterns and infrastructure, v1.3 minimizes risk while maximizing value delivery.